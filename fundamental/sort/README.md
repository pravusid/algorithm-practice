# 정렬: O(n^2)

## 정렬의 개념

정렬은 여러 원소로 구성된 데이터를 크기 순서에 따라 재배열하는 것

비교 기반 정렬은 데이터의 키 값을 비교하면서 정렬하는 방식으로, 시간 복잡도는 키의 비교횟수에 비례한다.
> 선택 정렬, 버블 정렬, 삽입 정렬, 셸 정렬, 합병 정렬, 퀵 정렬, 힙 정렬 ...

분포 기반 정렬은 데이터의 분포 정보를 이용하여 정렬하는 방식으로, 선형시간 복잡도를 가진다.
> 계수 정렬, 버킷 정렬, 기수 정렬 ...

안정적 정렬은 데이터의 키 값이 동일한 경우 정렬 후 기존 순서가 변하지 않는 정렬이다.

제자리 정렬은 입력받은 데이터가 저장된 공간 이외의 별도 공간을 상수개만 사용하는 정렬이다.

## 선택 정렬

선택정렬은 원소중 가장 작은 키값을 갖는 원소를 선택하여 차례대로 나열하는 정렬방식이다

`{ 30, 50, 7, 40, 88, 15, 44 }` 의 배열을 정렬해보면

1. 첫 번째 원소 30을 기준으로 오른쪽으로 최소값을 찾기 시작한다.
2. 50은 30보다 더 크므로 다시 오른쪽 값을 비교한다.
3. 7은 30보다 더 작으므로 7을 최소값 기준으로 설정한다
4. 40은 7보다 크므로 다시 오른쪽 값을 비교한다.
5. ... 마지막 원소인 44까지 진행한다
6. 44는 7보다 크므로 최소값은 7이된다.
7. 첫 번째 원소와 찾은 최소값인 7의 자리를 바꾼다.
8. 두 번째 원소를 대상으로 1 ~ 7 과정을 반복한다.

### 선택 정렬 알고리즘

```python
def SelectionSort(dlist):
    size = len(dlist)
    for element in range(size): # range는 반폐구간
        min_position = element
        for target in range(element + 1, size):
            if (dlist[target] < dlist[min_position]):
                min_position = target
        (dlist[element], dlist[min_position]) = (dlist[min_position], dlist[element])
```

### 선택 정렬 알고리즘 성능

선택 정렬 알고리즘은 이중 반복문으로 구성되며 둘 다 입력 배열 크기 `n`에 비례하므로 전체 수행시간은 `O(n^2)` 이다.
입력 배열 크기 이외의 인자가 없으므로 최악, 최선, 평균 수형시간 모두 `O(n^2)` 이다.

### 선택 정렬 특징

- 언제나 동일 수행시간 `O(n^2)`을 보임
- 안정적이지 않은 정렬임
- 제자리 정렬임: 데이터가 움직이는 경우는 두 원소 교환밖에 없음 (저장공간 이외의 공간을 상수개만 사용)

## 버블 정렬

버블 정렬은 인접한 두 원소를 차례대로 비교하면서 자리바꿈을 통해 정렬하는 방식이다.

`{ 30, 50, 7, 40, 88, 15, 44 }` 의 배열을 정렬해보면

1. 첫 번째 30과 두 번째 50을 비교한다.
2. 30이 50보다 작다. 두 번째 50과 세 번째 7을 비교한다.
3. 50이 7보다 크다. 두 수의 자리를 바꾼다.
4. 세 번째 50을 다시 네 번째 40과 비교한다.
5. 50이 40보다 크다. 두 수의 자리를 바꾼다.
6. ... 반복하여 n-1번째 원소와 n번째 원소를 비교할때 까지 진행한다.
7. 다시 1 ~ 6의 과정을, 정렬된 원소 이전까지 반복한다.

### 버블 정렬 알고리즘

```python
def BubbleSort(dlist):
    size = len(dlist) - 1
    for element in range(size):
        for head in range(size - element):
            if (dlist[head] > dlist[head + 1]):
                (dlist[head], dlist[head + 1]) = (dlist[head + 1], dlist[head])
```

### 버블 정렬 알고리즘 성능

버블 정렬 알고리즘은 이중 반복문으로 구성되며
바깥 반복은 조건에 따라 최소 상수, 최대 `n`에 비례하고, 안쪽 반복은 `n`에 비례한다.

수행시간은 최선의 경우 `O(n)`, 최악의 경우 `O(n^2)`, 평균의 경우 `O(n^2)`이다.

### 버블 정렬 특징

- 선택 정렬에 비해 원소의 교환이 많이 발생함: 수행시간이 최악인 경우 (`O(n^2)`) 선택 정렬보다 비효율적임
- 안정적인 정렬임
- 제자리 정렬임

## 삽입정렬

삽입 정렬은 주어진 원소들을 하나씩 뽑은 후, 뽑은 원소를 알맞은 위치에 삽입하여 나열하는 정렬 방식이다.

`{ 30, 50, 7, 40, 88, 15, 44 }` 의 배열을 정렬해보면

1. 배열의 왼쪽부터 하나씩 뽑는다. 우선 첫 번째 원소 30을 뽑는다.
2. 현재까지 나열된 원소는 없으므로 그대로 둔다.
3. 50을 뽑은 후 현재까지 나열된 원소와 비교한다.
4. 30보다 50이 크므로 그대로 둔다.
5. 7을 뽑은 후 현재까지 나열된 원소와 비교한다.
6. 마지막 원소 50보다 7이 작으므로 위치를 교환한다.
7. 정렬된 첫 번째 원소인 30까지 비교 및 교환을 반복한다.
8. 40을 뽑고 5~7 과정을 반복한다.

### 삽입정렬 알고리즘

```python
def InsertionSort(dlist):
    size = len(dlist)
    for e in range(size):
        for t in range(e):
            if dlist[e - t] < dlist[e - t - 1]:
                dlist[e - t - 1], dlist[e - t] = dlist[e - t], dlist[e - t - 1]
```

### 삽입 정렬 알고리즘 성능

삽입 정렬 알고리즘은 이중 루프로 구성되며
바깥 루프는 입력 배열의 크기 n에 비례하고, 안쪽 루프는 조건에 따라 최소 상수 최대 n에 비례한다.

전체 수행시간은 최선의 경우(모두 정렬되어 있는 경우) `O(n)`이며, 최악의 경우 `O(n^2)`이다. 평균 수행시간도 `O(n^2)`이다.

### 삽입정렬의 특징

- 입력이 거의 정렬된 경우 빠른 수행시간을 보임
- 안정적인 정렬임
- 제자리 정렬임

## 셸 정렬

Donald L. Shell이 고안한 것으로 처음에는 멀리 떨어진 두 원소를 비교하여 위치를 교환하고
점차 가까운 위치의 원소를 비교/교환 한 뒤 마지막에는 인접한 원소를 비교/교환 하는 정렬방식이다.

이는 삽입 정렬이 한 번에 한 요소의 위치만 변경되는 비효율을 보완한 것이다.

`{ 30, 50, 7, 40, 88, 15, 44 }` 의 배열을 정렬해보면

1. 전체 원소 개수가 `n`일 때, `gap = floor(n/2)` 만큼 떨어진 두 원소를 비교하며 정렬한다
2. 30-40-44, 50-88, 7-15, 40-44, 비교 (gap만큼 점프하며 마지막 원소까지 반복)
3. `gap = floor(3/2)` 만큼 떨어진 두 원소를 비교하며 정렬한다
4. `gap == 1`이 될때까지 비교/교환을 반복한다

### 셸 정렬 알고리즘

```python
def ShellSort(dlist):
    n = len(dlist)
    gap = n // 2

    while gap > 0:
        for i in range(gap, n):
            temp = dlist[i]
            j = i

            while j >= gap and dlist[j-gap] > temp:
                dlist[j] = dlist[j-gap]
                j -= gap

            dlist[j] = temp
        gap //= 2
```

### 셸 정렬 알고리즘 성능

셸 정렬 알고리즘의 수행시간은 최악의 경우 `O(n^2)`이고, 최선의 경우 `O(nlogn)`이다.

### 셸 정렬의 특징

- gap의 크기 계산방식에 따라 다양한 성능을 보인다
  - 기본적으로 1/2배 하며 구하였지만, 다양한 방식이 연구되었다.
- 안정적이지 않은 정렬임
- 제자리 정렬임
